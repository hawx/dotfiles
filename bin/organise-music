#!/usr/bin/env ruby
# -*- coding: utf-8 -*-
#
# Usage: organise-music [--dry-run] --music|--playlists
#
#   Organises the music library at MUSIC_ROOT so that all files within are named
#   according to the rules in 'music_util.rb'. With the '--playlists' flag will
#   instead rename files referenced in playlists to the correct names.
#
require_relative 'music_util'

# This script will reorganise a folder of music into a common structure. Beware!
# it will just move files based on metadata so if you have a bunch of files with
# no artist, album and track data they will be squashed into "Unknown
# Artist/Unknown Album/Unknown Track.mp3".
#
# The structure followed goes (in order-ish of preference):
# - "Album Artist/Album/Disc-Track Title.ext"
# - "Album Artist/Album/Track Title.ext"
# - "Album Artist/Album/Title.ext"
# - "Artist/Album/Disc-Track Title.ext"
# - "Artist/Album/Track Title.ext"
# - "Artist/Album/Title.ext"
# - ...
# - "Unknown Artist/Unknown Album/Unknown Track.ext"
#
# This is totally based on the metadata contained in the file, so if it doesn't
# exist or can't be read it will drop to defaults.
#
# You may need to change the constants at the top to have your MUSIC_ROOT and
# PLAYLIST_ROOT correct, I use an environment variable for MUSIC_ROOT
#
# Anyway to run, you will probably want to preview results:
#
#   $ organise-music --dry-run --music > results.txt
#
# If you are happy with this (hint: search for unknowns and fix!) fix playlists
# first, then music, otherwise playlists will be un-fixable:
#
#   $ organise-music --playlists
#   $ organise-music --music
#
# Afterwards delete empty folders with a quick
#
#   $ find "$MUSIC_ROOT" -depth -empty -type d -delete'
#
# And hopefully everything is nicely organised.

MUSIC_ROOT = Pathname.new(ENV['MUSIC_ROOT'])
PLAYLIST_ROOT = Pathname.new("/home/hawx/.config/mpd/playlists")

def music_changes(root)
  return enum_for(:music_changes, root) unless block_given?

  Dir[root + '**' + '*.*'].each do |path|
    next if Dir.exist?(path)

    corrected_path = path_for_song(root, path).to_s
    if path != corrected_path
      yield [path, corrected_path]
    end
  end
end

def list_music(enumerator)
  enumerator.each do |current, correct|
    puts "mv #{current} #{correct}"
  end
end

def fix_music(enumerator)
  enumerator.each do |current, correct|
    FileUtils.mkdir_p File.dirname(correct)
    FileUtils.mv current, correct
    puts "mv #{current} #{correct}"
  end
end

def playlist_changes(music_root, playlist_root)
  return enum_for(:playlist_changes, music_root, playlist_root) unless block_given?

  Dir[playlist_root + '**' + '*'].each do |path|
    next if Dir.exist?(path)

    changed = false
    contents = File.read(path).split("\n").map {|line|
      if line.empty? || line[0] == "#"
        line
      else
        new_line = path_for_song(music_root, line).to_s
        if new_line != line
          changed = true
        end
        new_line
      end
    }.join("\n")

    yield [path, contents] if changed
  end
end

def list_playlists(enumerator)
  enumerator.each do |path, contents|
    puts "Changed: #{path}"
    puts contents
    puts ""
  end
end

def fix_playlists(enumerator)
  enumerator.each do |path, contents|
    File.write(path, contents)
    puts "Wrote: #{path}"
  end
end

if File.identical?(__FILE__, $0)
  dry_run = !!ARGV.delete("--dry-run")
  puts "Dry run..."

  case ARGV[0]
  when "--music"
    changes = music_changes(MUSIC_ROOT)
    if dry_run
      list_music(changes)
    else
      fix_music(changes)
    end

  when "--playlists"
    changes = playlist_changes(MUSIC_ROOT, PLAYLIST_ROOT)
    if dry_run
      list_playlists(changes)
    else
      fix_playlists(changes)
    end
  end
end
